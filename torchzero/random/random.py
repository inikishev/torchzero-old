import random
import torch
from scipy import signal, ndimage

def randfill(shape, sampler = random.normalvariate, device=None, requires_grad = False, dtype=None):
    """Return tensor filled with one value sampled from some distribution."""
    return torch.zeros(shape, device=device, requires_grad=requires_grad, dtype=dtype).fill_(sampler())

def randfill_like(x:torch.Tensor, sampler = random.normalvariate):
    """Fill tensor with one value sampled from some distribution."""
    return randfill(x.shape, sampler=sampler, device=x.device, requires_grad=x.requires_grad, dtype=x.dtype)

def randrect(shape, fill = randfill_like, device=None, requires_grad = False, dtype=None):
    """Randomly placed rectangle filled values generated by `fill`."""
    # scalar is just random
    if len(shape) == 0:
        return fill()

    # create start-end slices for the rectangle
    slices = []
    for dim_size in shape:
        if dim_size == 1: slices.append(slice(None))
        else:
            start = random.randrange(0, dim_size-1)
            end = random.randrange(start, dim_size)
            slices.append(slice(start, end))
    # determine fill value
    res = torch.zeros(shape, device=device, requires_grad = requires_grad, dtype=dtype)
    res[slices] = fill(res[slices])
    return res

def randrect_like(x:torch.Tensor, fill = randfill_like):
    """Randomly placed rectangle filled with random value from normal distribution."""
    return randrect(x.shape, fill=fill, device=x.device, requires_grad=x.requires_grad, dtype=x.dtype)

def rademacher(shape, p=0.5, device=None, requires_grad = False, dtype=None):
    """100p% to draw a -1 and 100(1-p)% to draw a 1. Looks like this:
    ```
    [-1,  1,  1, -1, -1,  1, -1,  1,  1, -1, -1, -1,  1, -1,  1, -1, -1,  1, -1,  1]
    ```
    """
    if isinstance(shape, int): shape = (shape, )
    return torch.bernoulli(torch.full(shape, p, dtype=dtype, device=device, requires_grad=requires_grad)) * 2 - 1

def rademacher_like(x:torch.Tensor, p=0.5, ):
    """100p% to draw a -1 and 100(1-p)% to draw a 1. Looks like this:
    ```
    [-1,  1,  1, -1, -1,  1, -1,  1,  1, -1, -1, -1,  1, -1,  1, -1, -1,  1, -1,  1]
    ```
    """
    return rademacher(x.shape, p=p, device=x.device, requires_grad=x.requires_grad, dtype=x.dtype)

def randmask(shape, p=0.5, device=None, requires_grad = False):
    return torch.rand(shape, device=device, requires_grad=requires_grad) < p

def randmask_like(x:torch.Tensor, p=0.5, ):
    return randmask(x.shape, p=p, device=x.device, requires_grad=x.requires_grad)

def similar_like(x:torch.Tensor, sampler=torch.randn_like):
    if x.numel() <= 1: return x.clone()
    mean = x.mean()
    std = x.std()
    if std == 0:
        if mean == 0: return torch.zeros_like(x)
        else: return randfill_like(x, sampler=sampler)
    else:
        rand = sampler(x)
        randmean = rand.mean()
        randstd = rand.std()
        return rand * (std / randstd) + (mean - randmean * randstd / std)


def randconv(shape, kshape, mode='reflect', sampler = torch.randn, ksampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.ndimage.convolve with random tensor of shape kshaspe`"""
    if len(shape) > 1 and isinstance(kshape, int): kshape = [kshape] * len(shape)
    return torch.from_numpy(ndimage.convolve(sampler(shape), ksampler(kshape), mode=mode))

def randconv_like(x:torch.Tensor, kshape, mode='reflect', sampler = torch.randn, ksampler = torch.randn):
    """Generates a random tensor of shape `shape` and scipy.ndimage.convolve with random tensor of shape kshaspe"""
    return randconv(x.shape, kshape,mode=mode, sampler=sampler, ksampler=ksampler).to(dtype=x.dtype, device=x.device).requires_grad_(x.requires_grad)

def randorder(shape, kshape, rank = 1, sampler = torch.randn, ksampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.signal.order_filter with random tensor of shape kshaspe`"""
    if len(shape) > 1 and isinstance(kshape, int): kshape = [kshape] * len(shape)
    return torch.from_numpy(signal.order_filter(sampler(shape), ksampler(kshape), rank=rank))

def randorder_like(x:torch.Tensor, kshape, sampler = torch.randn, ksampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.signal.convolve with random tensor of shape kshaspe"""
    return randorder(x.shape, kshape, rank = 1, sampler=sampler, ksampler=ksampler).to(dtype=x.dtype, device=x.device).requires_grad_(x.requires_grad)

def randmedian(shape, kshape, mode='reflect', sampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.ndimage.median_filter`"""
    if len(shape) > 1 and isinstance(kshape, int): kshape = [kshape] * len(shape)
    return torch.from_numpy(ndimage.median_filter(sampler(shape), kshape, mode=mode))

def randmedian_like(x:torch.Tensor, kshape, mode='reflect', sampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.ndimage.median_filter"""
    return randmedian(x.shape, kshape, sampler=sampler, mode=mode).to(dtype=x.dtype, device=x.device).requires_grad_(x.requires_grad)

def randwiener(shape, kshape, noise=None, sampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.signal.wiener`"""
    if len(shape) > 1 and isinstance(kshape, int): kshape = [kshape] * len(shape)
    return torch.from_numpy(signal.wiener(sampler(shape), kshape, noise))

def randwiener_like(x:torch.Tensor, kshape, noise=None, sampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.signal.wiener"""
    return randwiener(x.shape, kshape, sampler=sampler,noise=noise).to(dtype=x.dtype, device=x.device).requires_grad_(x.requires_grad)

def randgaussian(shape, sigma=2, order=0, mode='reflect', sampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.ndimage.gaussian_filter`"""
    return torch.from_numpy(ndimage.gaussian_filter(sampler(shape), sigma=sigma, order=order, mode=mode))

def randgaussian_like(x:torch.Tensor, sigma=2, order=0, mode='reflect', sampler = torch.randn):
    """Generates a random tensor of shape `shape` and uses scipy.ndimage.gaussian_filter"""
    return randgaussian(x.shape, sigma=sigma, order=order, mode=mode, sampler=sampler).to(dtype=x.dtype, device=x.device).requires_grad_(x.requires_grad)


def uniform(shape, low, high, device=None, requires_grad=None, dtype=None):
    return torch.empty(shape, device=device, dtype=dtype, requires_grad=requires_grad).uniform_(low, high)

def uniform_like(x:torch.Tensor, low, high):
    return uniform(x.shape, low, high, device=x.device, requires_grad=x.requires_grad, dtype=x.dtype)

class Uniform:
    def __init__(self, low, high):
        self.low = low
        self.high = high

    def __call__(self, shape, device = None, requires_grad = None, dtype = None):
        return uniform(shape,self.low, self.high, device=device, requires_grad=requires_grad, dtype=dtype)

    def like(self, x:torch.Tensor):
        return uniform_like(x, self.low, self.high)